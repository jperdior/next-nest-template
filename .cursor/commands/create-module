## create-module

Creates a new **thin application module** (HTTP/CLI layer) in the DDD-based monorepo.

‚ö†Ô∏è **Important**: Modules are thin layers that consume bounded contexts. Domain logic belongs in `shared/contexts/`, not in modules!

### Instructions for AI Agent

When the user invokes this command, follow these steps carefully:

#### Step 1: Gather Information

Ask the user the following questions:

1. **Module name**: "What is the module name? (lowercase, alphanumeric, hyphens only, e.g., analytics, reports, notifications)"
   - Validate: Must be lowercase, alphanumeric, hyphens only
   - Must start and end with alphanumeric character
   - Examples: `analytics`, `user-reports`, `notification-service`

2. **Module type**: "What should this module include?"
   - Option 1: Both frontend and backend (full module)
   - Option 2: Frontend only
   - Option 3: Backend only

3. **Database schema** (if backend included): "How should this module handle database?"
   - Option 1: Use shared schema (default) - models go in `shared/contexts/Infrastructure/persistence/prisma/schema.prisma`
   - Option 2: Own schema - module will have its own `prisma/` folder and migrations

#### Step 2: Determine Port Numbers

Count existing modules in `modules/` directory and assign ports:
- Frontend port = 3000 + (module_count * 10)
- Backend port = 3001 + (module_count * 10)  
- Prisma Studio port = 5555 + (module_count * 1)

Examples:
- Module 0 (user-app): frontend=3000, backend=3001, prisma=5555
- Module 1 (backoffice): frontend=3010, backend=3011, prisma=5556
- Module 2 (analytics): frontend=3020, backend=3021, prisma=5557

#### Step 3: Create Directory Structure

Create the following structure in `modules/[module-name]/`:

```
modules/[module-name]/
‚îú‚îÄ‚îÄ backend/           (if backend selected)
‚îú‚îÄ‚îÄ frontend/          (if frontend selected)
‚îú‚îÄ‚îÄ ops/
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.backend    (if backend selected)
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile.frontend   (if frontend selected)
‚îú‚îÄ‚îÄ specs/
‚îÇ   ‚îî‚îÄ‚îÄ openapi.yaml   (if backend selected)
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ README.md
```

#### Step 4: Copy Template Files and Configure Database

**If creating backend:**
- Copy from `modules/user-app/backend/` to `modules/[module-name]/backend/`
- Update `package.json` name to `[module-name]-backend`
- Keep dependencies as-is (they reference shared packages)

**If database schema Option 1 (Shared) selected:**
- No prisma folder in module
- Module uses `@testproject/database` package
- DATABASE_URL: `postgresql://postgres:postgres@postgres:5432/testproject?schema=public`
- Volume mount shared schema: `../../../shared/contexts/Infrastructure/persistence:/app/shared/contexts/Infrastructure/persistence`

**If database schema Option 2 (Own Schema) selected:**
- Create `modules/[module-name]/backend/prisma/schema.prisma`
- Create `modules/[module-name]/backend/prisma/migrations/` folder
- DATABASE_URL: `postgresql://postgres:postgres@postgres:5432/testproject_[modulename]?schema=public`
- Add to module Makefile: `db-migrate-create`, `db-migrate`, `db-generate`, `db-studio` commands
- Volume mount module schema: `../../../modules/[module-name]/backend:/app/modules/[module-name]/backend`

**If creating frontend:**
- Copy from `modules/user-app/frontend/` to `modules/[module-name]/frontend/`
- Update `package.json` name to `[module-name]-frontend`
- Keep dependencies as-is

**Always create ops/ directory with:**

1. `docker-compose.yml` with:
   - Service names: `[module-name]-backend`, `[module-name]-frontend`
   - Container names: `testproject_[modulename]_backend`, `testproject_[modulename]_frontend`
   - Correct ports assigned in Step 2
   - Network: `testproject_network` (no network definition needed - uses infra network)
   - DATABASE_URL with `testproject` database name
   - Proper volume mounts pointing to `modules/[module-name]/`
   - Depends on postgres, redis, rabbitmq from infra
   - Traefik labels for routing

2. `Dockerfile.backend` (if backend):
   - Copy from `modules/user-app/ops/Dockerfile.backend`
   - Update all paths to reference `modules/[module-name]/`

3. `Dockerfile.frontend` (if frontend):
   - Copy from `modules/user-app/ops/Dockerfile.frontend`
   - Update all paths to reference `modules/[module-name]/`

#### Step 5: Create specs/openapi.yaml

If backend is included, copy `modules/user-app/specs/openapi.yaml` and update:
- Title to "[ModuleName] API"
- Description

#### Step 6: Create Module Makefile

Create `modules/[module-name]/Makefile` with:
- MODULE_NAME variable set to module name
- Commands: start, stop, restart, logs, shell-be, shell-fe, test, lint, codegen
- Container names using: `testproject_[modulename]_backend` and `testproject_[modulename]_frontend`

Copy structure from `modules/user-app/Makefile` and update container names.

#### Step 7: Create Module README.md

Create a README with:
- Module purpose (ask user for description)
- Structure overview
- Quick start commands
- Access URLs with the assigned ports

#### Step 8: Update Root Orchestration

Update `ops/docker-compose.yml` to include the new module:
```yaml
include:
  - ../infra/docker-compose.yml
  - ../modules/user-app/ops/docker-compose.yml
  - ../modules/backoffice/ops/docker-compose.yml
  - ../modules/[module-name]/ops/docker-compose.yml  # ADD THIS
```

#### Step 9: Optional Root Makefile Commands

Ask the user: "Would you like to add convenience commands to the root Makefile? (y/n)"

If yes, add to root `Makefile`:
```makefile
# [ModuleName] Module
start-[module-name]:
	@$(MAKE) -C modules/[module-name] start

stop-[module-name]:
	@$(MAKE) -C modules/[module-name] stop

logs-[module-name]:
	@$(MAKE) -C modules/[module-name] logs

shell-[module-name]-be:
	@$(MAKE) -C modules/[module-name] shell-be

shell-[module-name]-fe:
	@$(MAKE) -C modules/[module-name] shell-fe

test-[module-name]:
	@$(MAKE) -C modules/[module-name] test
```

Also update the help section to include the new module.

#### Step 10: Summary

Provide a summary:
```
‚úÖ Module Created: [module-name]

üìÅ Structure:
   - Backend: modules/[module-name]/backend/ [if created]
   - Frontend: modules/[module-name]/frontend/ [if created]
   - Ops: modules/[module-name]/ops/
   - Specs: modules/[module-name]/specs/ [if backend]

üåê Access URLs:
   - Frontend: http://localhost:[frontend_port] [if created]
   - Backend: http://localhost:[backend_port] [if created]
   - Prisma Studio: http://localhost:[prisma_port] [if backend]

üìã Next Steps:
   1. Review and customize the module code
   2. Update specs/openapi.yaml with your API endpoints [if backend]
   3. Run: cd modules/[module-name] && make codegen [if backend]
   4. Run: make start (from root) to start all services
   5. Or: cd modules/[module-name] && make start (after infrastructure is running)

üí° Tips:
   - Infrastructure must be running: make start-infra
   - Each module can be started independently
   - **Modules are THIN** - domain logic goes in shared/contexts/
   - Import bounded contexts: see DDD_GUIDE.md
   - Database: Shared schema (default) or own schema (optional) - see DDD_GUIDE.md
```

### Important Notes

1. **Always validate module name** before proceeding
2. **Always use testproject** as the network and database name
3. **Port allocation is critical** - ensure no conflicts
4. **Update docker-compose volume paths** to point to the correct module
5. **Container names follow pattern**: `testproject_[modulename]_[service]`
6. **Modules are THIN** - they import bounded contexts from `shared/contexts/`
7. **No domain logic in modules** - entities, repositories go in contexts
8. **Ask user for module purpose** to include in README
9. **Guide user to create contexts** if they need domain logic (see DDD_GUIDE.md)

### Docker Compose Template Structure

Key parts for the module's `ops/docker-compose.yml`:

```yaml
version: '3.8'

services:
  [module-name]-backend:  # If backend
    build:
      context: ../../..
      dockerfile: modules/[module-name]/ops/Dockerfile.backend
    container_name: testproject_[modulename]_backend
    environment:
      PORT: [backend_port]
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/testproject?schema=public
    ports:
      - "[backend_port]:[backend_port]"
      - "[prisma_port]:5555"
    volumes:
      - ../../../modules/[module-name]/backend:/app/modules/[module-name]/backend
      - ../../../shared/contexts/Infrastructure/persistence:/app/shared/contexts/Infrastructure/persistence  # For shared schema
      # OR for own schema: - ../../../modules/[module-name]/backend:/app/modules/[module-name]/backend
    networks:
      - testproject_network
    
  [module-name]-frontend:  # If frontend
    build:
      context: ../../..
      dockerfile: modules/[module-name]/ops/Dockerfile.frontend
    container_name: testproject_[modulename]_frontend
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:[backend_port]
    ports:
      - "[frontend_port]:[frontend_port]"
    networks:
      - testproject_network
```

**Note**: Do NOT include a `networks:` definition section at the bottom. The network is defined in `infra/docker-compose.yml` and shared via the `include` directive in `ops/docker-compose.yml`.

### Example Invocation

```
User: /create-module
AI: What is the module name? (lowercase, alphanumeric, hyphens only)
User: analytics
AI: What should this module include?
    1. Both frontend and backend
    2. Frontend only
    3. Backend only
User: 1
AI: What is the purpose of this module? (for README)
User: Analytics dashboard for viewing user metrics and reports
AI: [Proceeds to create module...]
    ‚úÖ Created modules/analytics/
    [... full summary ...]
```
