# Backend Testing Guide

This document describes the testing strategy, patterns, and best practices for the backend application.

## Testing Philosophy

- **Test behavior, not implementation** - Tests should verify what the code does, not how it does it
- **Fast feedback** - Unit tests run in milliseconds, integration tests in seconds
- **Confidence** - Tests should catch bugs before they reach production
- **Maintainability** - Tests should be easy to understand and update

## Test Types

### Unit Tests

**Purpose**: Test individual components in isolation.

**What to Test**:
- Value objects and their validation logic
- Entity business methods
- Domain services
- Use case services (with mocked repositories)

**Location**: `test/unit/context/[feature]/`

**Characteristics**:
- Fast (< 10ms per test)
- No database, no HTTP, no external dependencies
- Use mocks/stubs for dependencies
- Focus on business logic

### Integration Tests

**Purpose**: Test components working together.

**What to Test**:
- HTTP endpoints (controllers)
- Database operations (repositories)
- Full request/response cycle

**Location**: `test/integration/context/[feature]/`

**Characteristics**:
- Slower (100ms - 1s per test)
- Use real database (test database)
- Test actual HTTP requests
- Verify end-to-end behavior

## Test Structure

### Unit Test Pattern

```typescript
// test/unit/context/example/domain/value-objects/item-name.spec.ts

import { ItemName } from '@context/example/domain/value-objects/item-name.value-object';

describe('ItemName Value Object', () => {
  describe('create', () => {
    it('should create valid item name', () => {
      const name = ItemName.create('Valid Name');
      
      expect(name.getValue()).toBe('Valid Name');
    });

    it('should reject name shorter than 3 characters', () => {
      expect(() => ItemName.create('ab')).toThrow();
    });

    it('should reject name longer than 100 characters', () => {
      const longName = 'a'.repeat(101);
      expect(() => ItemName.create(longName)).toThrow();
    });
  });

  describe('equals', () => {
    it('should return true for same value', () => {
      const name1 = ItemName.create('Test');
      const name2 = ItemName.create('Test');
      
      expect(name1.equals(name2)).toBe(true);
    });

    it('should return false for different values', () => {
      const name1 = ItemName.create('Test1');
      const name2 = ItemName.create('Test2');
      
      expect(name1.equals(name2)).toBe(false);
    });
  });
});
```

### Integration Test Pattern

```typescript
// test/integration/context/example/presentation/http/items.controller.spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '@/app.module';
import { PrismaService } from '@shared/database/prisma.service';

describe('ItemsController (Integration)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
      })
    );
    
    prisma = app.get<PrismaService>(PrismaService);
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    // Clean database before each test
    await prisma.item.deleteMany();
  });

  describe('POST /items', () => {
    it('should create item with valid data', async () => {
      const createDto = {
        name: 'Test Item',
        description: 'Test Description',
      };

      const response = await request(app.getHttpServer())
        .post('/items')
        .send(createDto)
        .expect(201);

      expect(response.body).toMatchObject({
        id: expect.any(String),
        name: 'Test Item',
        description: 'Test Description',
        createdAt: expect.any(String),
        updatedAt: expect.any(String),
      });
    });

    it('should reject name shorter than 3 characters', async () => {
      const createDto = {
        name: 'ab',
        description: 'Test',
      };

      await request(app.getHttpServer())
        .post('/items')
        .send(createDto)
        .expect(400);
    });

    it('should create item without description', async () => {
      const createDto = {
        name: 'Test Item',
      };

      const response = await request(app.getHttpServer())
        .post('/items')
        .send(createDto)
        .expect(201);

      expect(response.body.description).toBeUndefined();
    });
  });

  describe('GET /items', () => {
    it('should return empty array when no items', async () => {
      const response = await request(app.getHttpServer())
        .get('/items')
        .expect(200);

      expect(response.body).toEqual([]);
    });

    it('should return all items', async () => {
      // Seed test data
      await prisma.item.createMany({
        data: [
          { name: 'Item 1', description: 'First' },
          { name: 'Item 2', description: 'Second' },
        ],
      });

      const response = await request(app.getHttpServer())
        .get('/items')
        .expect(200);

      expect(response.body).toHaveLength(2);
      expect(response.body[0]).toMatchObject({
        name: expect.any(String),
        description: expect.any(String),
      });
    });
  });
});
```

## Testing by Layer

### Domain Layer Tests

**Focus**: Business logic, validation, invariants.

**Example - Entity Test**:
```typescript
describe('ItemEntity', () => {
  describe('constructor', () => {
    it('should create item with valid data', () => {
      const props = {
        id: '123e4567-e89b-12d3-a456-426614174000',
        name: 'Test Item',
        description: 'Test',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const item = new ItemEntity(props);

      expect(item.getId()).toBe(props.id);
      expect(item.getName()).toBe(props.name);
    });

    it('should reject invalid name', () => {
      const props = {
        id: '123e4567-e89b-12d3-a456-426614174000',
        name: 'ab',  // Too short
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      expect(() => new ItemEntity(props)).toThrow();
    });
  });

  describe('updateName', () => {
    it('should update name and updatedAt', () => {
      const item = createTestItem();
      const originalUpdatedAt = item.getUpdatedAt();

      // Wait a bit to ensure timestamp changes
      jest.advanceTimersByTime(1000);
      
      item.updateName('New Name');

      expect(item.getName()).toBe('New Name');
      expect(item.getUpdatedAt()).not.toEqual(originalUpdatedAt);
    });
  });
});
```

### Application Layer Tests

**Focus**: Use case orchestration, input validation, output formatting.

**Example - Use Case Test**:
```typescript
describe('CreateItemService', () => {
  let service: CreateItemService;
  let mockRepository: jest.Mocked<ItemRepositoryInterface>;

  beforeEach(() => {
    mockRepository = {
      create: jest.fn(),
      findById: jest.fn(),
      findAll: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    };

    service = new CreateItemService(mockRepository);
  });

  it('should create item with valid input', async () => {
    const input = {
      name: 'Test Item',
      description: 'Test Description',
    };

    const createdEntity = new ItemEntity({
      id: '123e4567-e89b-12d3-a456-426614174000',
      name: input.name,
      description: input.description,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    mockRepository.create.mockResolvedValue(createdEntity);

    const result = await service.execute(input);

    expect(result).toBeInstanceOf(CreateItemOutput);
    expect(result.name).toBe(input.name);
    expect(mockRepository.create).toHaveBeenCalledTimes(1);
  });

  it('should reject invalid input', async () => {
    const input = {
      name: 'ab',  // Too short
    };

    await expect(service.execute(input)).rejects.toThrow();
    expect(mockRepository.create).not.toHaveBeenCalled();
  });
});
```

### Infrastructure Layer Tests

**Focus**: Database operations, external integrations.

**Note**: Usually tested via integration tests (testing controllers that use repositories).

If testing repositories directly:
```typescript
describe('ItemPrismaRepository', () => {
  let repository: ItemPrismaRepository;
  let prisma: PrismaService;

  beforeAll(async () => {
    const module = await Test.createTestingModule({
      providers: [ItemPrismaRepository, PrismaService],
    }).compile();

    repository = module.get<ItemPrismaRepository>(ItemPrismaRepository);
    prisma = module.get<PrismaService>(PrismaService);
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    await prisma.item.deleteMany();
  });

  it('should create item', async () => {
    const entity = new ItemEntity({
      id: '123e4567-e89b-12d3-a456-426614174000',
      name: 'Test',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const result = await repository.create(entity);

    expect(result).toBeInstanceOf(ItemEntity);
    expect(result.getId()).toBe(entity.getId());
  });
});
```

### Presentation Layer Tests

**Focus**: HTTP handling, request/response mapping, validation.

See integration test pattern above.

## Test Utilities

### Test Factories

Create reusable test data:

```typescript
// test/factories/item.factory.ts

export function createTestItem(overrides?: Partial<ItemEntityProps>): ItemEntity {
  return new ItemEntity({
    id: '123e4567-e89b-12d3-a456-426614174000',
    name: 'Test Item',
    description: 'Test Description',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    ...overrides,
  });
}
```

Usage:
```typescript
const item = createTestItem({ name: 'Custom Name' });
```

### Mock Repositories

```typescript
export function createMockItemRepository(): jest.Mocked<ItemRepositoryInterface> {
  return {
    create: jest.fn(),
    findById: jest.fn(),
    findAll: jest.fn(),
    update: jest.fn(),
    delete: jest.fn(),
  };
}
```

## Jest Configuration

```javascript
// jest.config.ts
export default {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: '.',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.(t|j)s',
    '!src/**/*.module.ts',
    '!src/**/*.interface.ts',
    '!src/main.ts',
  ],
  coverageDirectory: './coverage',
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@context/(.*)$': '<rootDir>/src/context/$1',
    '^@shared/(.*)$': '<rootDir>/src/shared/$1',
  },
};
```

## Running Tests

```bash
# All tests
pnpm test

# Watch mode
pnpm test:watch

# Specific file
pnpm test item.entity.spec.ts

# With coverage
pnpm test:cov

# Integration tests only
pnpm test test/integration

# Unit tests only
pnpm test test/unit
```

## Coverage Goals

- **Overall**: > 80%
- **Domain Layer**: > 95% (critical business logic)
- **Application Layer**: > 90%
- **Infrastructure Layer**: > 70% (harder to test, covered by integration tests)
- **Presentation Layer**: > 80%

## Best Practices

### ✅ DO

- Write tests for all business logic
- Test edge cases and error conditions
- Use descriptive test names
- Keep tests independent (no shared state)
- Clean up after tests (database, mocks)
- Use factories for test data
- Test one thing per test
- Mock external dependencies in unit tests

### ❌ DON'T

- Test implementation details
- Write tests that depend on execution order
- Use real external services in tests
- Skip cleanup in `afterEach`/`afterAll`
- Write overly complex tests
- Use `any` in test expectations
- Commit failing tests

## Debugging Tests

### Run Single Test

```bash
pnpm test -t "should create item with valid data"
```

### Debug with VSCode

Add to `.vscode/launch.json`:

```json
{
  "type": "node",
  "request": "launch",
  "name": "Jest Debug",
  "program": "${workspaceFolder}/backend/node_modules/.bin/jest",
  "args": ["--runInBand", "${file}"],
  "console": "integratedTerminal",
  "internalConsoleOptions": "neverOpen"
}
```

### Increase Timeout

```typescript
it('long running test', async () => {
  // Test code
}, 10000);  // 10 second timeout
```

## Continuous Integration

Tests run automatically on:
- Pre-commit (changed files only)
- Pull requests (all tests)
- Main branch (all tests with coverage)

## Common Issues

### Database Connection Errors

Ensure test database is running and `DATABASE_URL` is set:

```bash
# Start test database
docker compose up -d postgres

# Set test database URL
export DATABASE_URL="postgresql://postgres:postgres@localhost:5432/myproject_test"
```

### Test Timeouts

Increase Jest timeout or optimize slow tests:

```typescript
jest.setTimeout(10000);  // 10 seconds
```

### Flaky Tests

- Check for race conditions
- Ensure proper cleanup
- Avoid time-dependent assertions
- Use `waitFor` for async operations

## Summary

- **Unit tests**: Fast, isolated, test business logic
- **Integration tests**: Slower, test components working together
- **Test each layer**: Domain, Application, Infrastructure, Presentation
- **High coverage**: Especially in Domain and Application layers
- **Clean tests**: Independent, descriptive, maintainable

Write tests as you code, not after. They're your safety net!
